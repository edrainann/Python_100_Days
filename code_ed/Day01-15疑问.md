1、
```python
def is_substring(s1,s2):
    return True if s2.find(s1)!=-1 else False
```
等同于
```python
def is_substring(s1,s2):
   tag = False
   if s2.find(s1) != -1:
        tag = True
   return tag
```

2、yield 生成器使用

3、
rfind() 返回字符串最后一次出现的位置(从右向左查询)，如果没有匹配项则返回-1

4、Day07
三元表达式：
 h = "变量1" if a>b else "变量2"，即 如果a>b的结果为真，h="变量1",如果为假，h="变量2"
 index = pos if has_dot else pos + 1
 如果has_dot的结果为真，index=pos；如果has_dot的结果为假，index=pos+1
 
5、
```python
def is_leap_year(year):
    return year % 4 == 0 and year % 100 != 0 or year % 400 == 0
    
def which_day(year, month, date):
    days_of_month = [
        [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
        [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    ][is_leap_year(year)]
```
其中is_leap_year返回的值为True 或者 False，而True==1，False==0。即：
```python
def t_true():
    a = [[11, 111], [22, 222], [33, 333]]
    days01 = a[0]
    days02 = a[True]
    content = f'days01:{days01},days02:{days02}'
    return content
```

6、
双色球选号、约瑟夫问题、井子棋游戏 暂时还未理解

7、format
```python
# 2是宽度很简单。如果整数不够2列就补上0
time = f'{self._hour:02d}:{self._minute:02d}:{self._second:02d}'
time = '%02d:%02d:%02d' % (self._hour, self._minute, self._second)  
```

8、Day08
__str__()函数
__str__( )函数和__init__( )函数一样，都是python中的特殊函数，一般来说，打印对象会返回对象的地址，而地址信息通常对我们没有什么用，通过__str__( )函数可以打印对象的属性信息，方便我们调试代码。

9、Day09
python 里面的单下划线与双下划线的区别(私有和保护)
```python
_xxx   #不能用于’from module import *’ 以单下划线开头的表示的是protected类型的变量。即保护类型只能允许其本身与子类进行访问。
__xxx  #双下划线的表示的是私有类型的变量。只能是允许这个类本身进行访问了。连子类也不可以
__xxx___ #定义的是特列方法。像__init__之类的
```
核心风格：避免用下划线作为变量名的开始。
因为下划线对解释器有特殊的意义，而且是内建标识符所使用的符号，我们建议程序员避免用下划线作为变量名的开始。一般来讲，变量名_xxx被看作是“私有 的”，在模块或类外不可以使用。当变量是私有的时候，用_xxx 来表示变量是很好的习惯。因为变量名__xxx__对Python 来说有特殊含义，对于普通的变量应当避免这种命名风格。
"单下划线" 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；
"双下划线" 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。
以单下划线开头（_foo）的代表不能直接访问的类属性，需通过类提供的接口进行访问，不能用“from xxx import *”而导入；以双下划线开头的（__foo）代表类的私有成员；以双下划线开头和结尾的（__foo__）代表python里特殊方法专用的标识，如 __init__（）代表类的构造函数。

10、Day09
实例方法、类方法、静态方法区分
1)参数区别：实例方法--传self、类方法--传cls、静态方法--什么都不传
2)类属性、以及所有的方法都在类对象里面，
实例对象可以有N个，类对象只有一个
实例对象里面可以独有的 只能是属性，连方法都是共享的
3)实例对象可以调：实例方法、类方法、静态方法
类对象只能调 ：类方法、静态方法，无法调实例方法

11、Day09
@abstractmethod
我们将Pet类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过abc模块的ABCMeta元类和abstractmethod包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。
抽象类的特点：不能直接被实例化；
抽象类的目的：让别的类继承它并实现特定的抽象方法；
Q--继续理解抽象类

12、Day09
扑克游戏、工资结算系统 暂时未看

13、Day10
global的作用对象是全局变量，nonlocal的作用对象是外层变量（很显然就是闭包这种情况）
global与nonlocal的区别：
第一，两者的功能不同。global关键字修饰变量后标识该变量是全局变量，对该变量进行修改就是修改全局变量，而nonlocal关键字修饰变量后标识该变量是上一级函数中的局部变量，如果上一级函数中不存在该局部变量，nonlocal位置会发生错误（最上层的函数使用nonlocal修饰变量必定会报错）。
第二，两者使用的范围不同。global关键字可以用在任何地方，包括最上层函数中和嵌套函数中，即使之前未定义该变量，global修饰后也可以直接使用，而nonlocal关键字只能用于嵌套函数中，并且外层函数中定义了相应的局部变量，否则会发生错误（见第一）

14、Day10
作用域：局部（Local）作用域 > 封闭（Enclosing）作用域 > 全局（Global）作用域 > 内置（Built-in）作用域
LEGB规则: Local -> Enclosing -> Global -> Built-in

